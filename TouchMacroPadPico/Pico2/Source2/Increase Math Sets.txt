Increase Math Sets to 10 Pad [s] change to number [1] -> [9] if different Math Set is active
Increase the Label length for Math Sets from 3 to 5

manual.h

line 853

(O) *ma*n with n = 0-9 or *ma* with no number added. Load Symbol set 0-9. You can now use up to 1080 Special Symbols 
   (Math and Greek etc). Load symbol set 0-9 using *ma*0-9 or by using the [Load] key in the Symbols page - if the file 
   Math0 to Math9 exists on the SDCard it is loaded as the current symbol set. Read mathKeys.h for more instructions - 
   you can use *ma* with no number added to save the 3 Math Arrays in mathKeys.h to the SDCard as file MathX.    
------------------------------------------------------------------------------------------------------------------------
Symbols-SpecialChar-Math-Greek-Algebra Keyboard: 

Press Pad [s]. This is a triple-key macro keyboard with 4 pages and 4 x 9 x 3 = 108 Special characters, Math/Algebra, 
and Greek symbols. You can load up to 10 different symbol sets i.e. you can access up to 1080 Special Symbols 
(Math and Greek etc). 

Ten sets of symbols can be loaded using the [Load] key - it will cycle through all 10 sets and load the set if it is 
available as file MathX with X = 0-9 on the SDCard. When a new set is found and loaded the Pad [S] will change to the
new Symbol set number i.e. pad [1] to [pad [9]. Symbol sets can also be loaded using *ma*X with x=0-9 using the Macro
Editor. *ma* with no number will save the current set as defined in mathKeys.h to the SDCard as file MathX. You can
then rename the file to any of Math0-Math9 by using MathX=Math2 and the [Ren] key in the Macro Editor - make sure 
both source and destination are brown (SDCard) not white (Flash). Two Symbol sets are provided in mathKeys.h - the 
second is commented out. Both sets Math0 and Math1 are included in SDCard-MathSets.zip. If no file Math0 is on
the SDCard it will be created when the TouchMacroPad is powered on or on reset, from the definition in mathKeys.h

The symbol is sent to the PC as a 4-character hex Unicode followed by [ALT] + [x] and can be directly entered into 
MSWord and in LibreOffice (also on Linux). Watch out for MSWord insisting on capitalising the first letter of a 
sentence - which will change the first math symbol in a sentence or line after a second symbol or letter or enter 
is typed. 

The three control keys are labelled [Load] (Page1 and Page3) or [Exit] (Page2 and Page4), and [Send] - send the symbol 
to the PC, [Page1-4] - next page of symbols. Press [Exit] to go back to the main Config layout or press the small blue 
pad [S] again to close the Symbols keyboard.

mathKeys.h has a few examples of using Alt + Number Keypad for Maths and special symbols or characters. There are 2 ways 
to do it - the first is to type the character's Unicode (hex without the 0x or decimal) into MSWord and then press
[ALT] + [x]. The second method is to hold the Alt key down, then type in a special code number using the number keypad 
and then release the Alt key. There are examples of entering the open infinity symbol and the small pi 
symbol in mathKeys.h.



line 83 mathKey.h

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int MathSet = 0;                       // 0=Default 1-9 other Math Symbols Set
const static int statusSz = 32;                                                     // Character space in statusbar
const static char statusBlank[statusSz + 1]  = "                                ";  // To clear statusbar

const static char MathLabel[4][12][6] =                                             // 4 Pages x 12 Keys x 6 chars (end 0)                                              
{"abg",  "dez",  "ehi",  "Exit", "klm",   "nko",  "prs",  "Page1", "stu",  "fcp",  "oO ",  "Print",
 "GDT",  "LKP",  "SFP",  "Exit", "OSet1", "Set2", "Set3", "Page2", "Set4", "Var1", "Var2", "Print",
 "Alg1", "Cal1", "Cal2", "Exit", "Alg2",  "Cal3", "Com1", "Page3", "Com2", "Mod1", "Mod2", "Print", 
 "Log1", "Log2", "Log3", "Exit", "Log4",  "Mod3", "Mod4", "Page4", "Mod5", "Set5", "Set6", "Print"  };
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Type in Alt + Numpad key then after symbol show press Alt+X to get hex codes used below
// MathNum[4][3][12][5] -> 4 pages x 3 options per key x 12 keys x 5 chars per uni(hex)code
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const static char MathNum[4][3][12][5] = 
{"03B1",  "03B4",   "03B7",  "0   ",  "03BA",   "03BD",   "03C0",   "0  ",  "03C3",  "03C6",  "03C9", "0  ",
 "03B2",  "03B5",   "03B8",  "0   ",  "03BB",   "03BE",   "03C1",   "0  ",  "03C4",  "03C7",  "03A9", "0  ",
 "03B3",  "03B6",   "03B9",  "0   ",  "03BC",   "03BF",   "03C2",   "0  ",  "03C5",  "03C8",  "0020", "0  ",
 "0393",  "039B",   "03A3",  "0   ",  "03A9",   "222A",   "2209",   "0  ",  "2284",  "22C5",  "2225", "0  ",
 "0394",  "039E",   "03A6",  "0   ",  "2288",   "2229",   "2205",   "0  ",  "2216",  "2A2F",  "00B0", "0  ",
 "0398",  "03A0",   "03A8",  "0   ",  "2A06",   "2208",   "2282",   "0  ",  "2286",  "00B1",  "221E", "0  ",
 "2211",  "2230",   "222D",  "0   ",  "221C",   "220F",   "2260",   "0  ",  "2261",  "0303",  "0307", "0  ",
 "2192",  "222B",   "222E",  "0   ",  "221A",   "2202",   "2248",   "0  ",  "2264",  "0304",  "0308", "0  ",
 "2207",  "222C",   "222F",  "0   ",  "221B",   "2032",   "221D",   "0  ",  "2265",  "20D7",  "2033", "0  ", 
 "21D2",  "2204",   "22BB",  "0   ",  "00AC",   "2070",   "2080",   "0  ",  "2099",  "2A1D",  "2A4F", "0  ",
 "21D4",  "22A4",   "2227",  "0   ",  "22A2",   "2071",   "2081",   "0  ",  "1D62",  "2A3F",  "2A4E", "0  ",
 "2203",  "22A5",   "2228",  "0   ",  "22A8",   "02B2",   "2082",   "0  ",  "2C7C",  "2A40",  "2A72", "0  " }; 

//MathName[4][3][12][32] -> 4 pages x 3 options per key x 12 keys x 32 chars per description
const static char MathName[4][3][12][statusSz] = 
{"alpha", "delta",   "eta",   "0", "kappa",              "nu",          "pi",                      "0",     "sigma2",         "phi",          "omega",                  "0",
 "beta",  "epsilon", "theta", "0", "lambda",             "xi",          "rho",                     "0",     "tau",            "chi",          "Omega",                  "0",
 "gamma", "zeta",    "iota",  "0", "mu",                 "omicron",     "sigma1",                  "0",     "upsilon",        "psi",          "space",                  "0",
 "Gamma", "Lambda", "Sigma",  "0", "Omega",              "union",       "not-element-of",          "0",     "not-subsetof",   "dotproduct",   "parallel",               "0",
 "Delta", "Xi",     "Phi",    "0", "not-subset-or-equal","intersection","empty-set",               "0",     "setdifference",  "crossproduct", "degree",                 "0",
 "Theta", "Pi",     "Psi",    "0", "disjoint-union",     "element-of",  "subset-of",               "0",     "subset-or-equal","plusminus",    "infinity",               "0",
 "sum",  "volume-integral","triple-integral", "0", "fourth-root", "n-ary-prod",    "notequal",     "0", "identicalto",   "combining-tilde", "combining-dot",            "0",
 "arrow","integral",       "line-integral",   "0", "square-root", "partial-deriv", "almostequal",  "0", "lessorequal",   "combining-bar",   "combining-2dot",           "0",
 "nabla","double-integral","surface-integral","0", "cube-root",   "prime",         "proportional", "0", "greaterorequal","combining-arrow", "double-prime",             "0",
 "arrow-implies",          "there-does-not-exists", "xor",  "0", "not",    "sup-0", "sub-0",       "0", "sup-n", "join",                 "double-square-union",         "0", 
 "arrow-if-and-only-if",   "unconditionally-true",  "and",  "0", "proves", "sup-i", "sub-1",       "0", "sub-i", "amalgamation",         "double-square-intersection",  "0",   
 "there-exists",           "unconditionally-false", "or",   "0", "models", "sup-j", "sub-2",       "0", "sub-j", "intersection-with-dot","plus-sign-above-equals-sign", "0" }; 


line 88

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 0   KeySkip 1  CheckSerial 0  KeyHeldEnable  1           BLOnOff 1    Rotate180 0              KeyFontBold 0      ResetOnceEnable 0
// 7     nKeys 1       nChar  n      nKeysPage  8  nKeysCharSet[10] c         CRLF 0                    crlf1 0x0D             crlf2 0x0A
// 23    iList 0       MuteOn 0           VolOn 1          LayerAxD 0        Media 0                   XFiles 0           Brightness 0           
// 30   BsDNum 0       RetNum 8         LayerAD 0     KeyFontColour 0   SaveLayout 2                 OptionOS 0            KeyRepeat 6 
// 37  NormVal 0       DimVal 3         nKeys34 1          nDir[20] c        nDirZ always=0  nKeysLnkChar[10] 10               nDirX 0,1,2,3
// 72   MLabel 0       SLabel 0          TLabel 0      DelayTimeVal 0      VolOn1  0                  VolOn2  1               VolOn3 1          ToneOn 0  
// 80  MathSet 0    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Currently last used entry MathSet 0-9 = Config1[80]; Can use strcpy((char *)&Config1[40], nDir); and inverse, to access as char string array nDirZ=0=EOS 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
cSt byte Config1Size = 90;       //   0   1   2   3   4   5   6   7  8  9  10  11  12  13  14  15  16  17  18  19 20 21   22   23 24 25 26 27 28 29  30  31 
byte Config1[Config1Size]          = {1,  0,  1,  1,  0,  0,  0,  1,'n',8,'n','o','p','q','r','s','t','m','a','k',0, 0x0D,0x0A,0, 1, 0, 0, 0, 0, 0,  0,  8, 
                                      0,  0,  2,  0,  6,  0,  3,  1,'/',0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,   0,   0, 0, 0, 0, 0, 0,'n','o','p',
                                     'q','u','v','w','x','y','z', 0, 0, 0, 0,  0,  0,  1,  1,  0,  0,  0,  0,  0, 0, 0,   0,   0, 0, 0  };
cSt byte Config1Reset[Config1Size] = {1,0,1,1,0,0,0,1,'n',8,'n','o','p','q','r','s','t','m','a','k',0,0x0D,0x0A,0, 1, 0, 0, 0, 0, 0,  0,  8, 
                                      0,0,2,0,6,0,3,1,'/',0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,0,   0,   0, 0, 0, 0, 0, 0,'n','o','p',
                                     'q','u','v','w','x','y','z', 0, 0, 0, 0,  0,  0,  1,  1,  0,  0,  0,  0,  0, 0, 0,   0,   0, 0, 0  };                                    
bool WriteConfig1Change = false; // Do save if true
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 


line 282

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// if MLabel SLabel TLabel > 0 use 5-char max labels in files MLabel SLabel TLabel instead of M,S,T 1 - M,S,T 24
// Also MathKeys label can be up to 5 chars
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char keyLabel[12][6] = {""};               //  Size = 144 at 5 characters max n0000 - n9999

// Custom Label up to five characters for 24 M,S,T keys used if MLabel 1 SLabel 1 TLabel 1
// Then read contents of the filename in file LabelM,S,T into LabelArrM,S,T 
// Need fast access to this - cannot read from SDCard every time
char LabelArr[3][24][6];      // Size 144*3=432 LabelArr[0] M LabelArr[1] S LabelArr[2] T custom keys
bool MLabel, SLabel, TLabel;  // if>0 then custom labels for 24 M,S.T keys
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

line 404
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CmKey = false;                 // Check if *codes are from pressing [*Cm] key or entered directly
const static int StarCodesMax = 97; // StarCodes Count 16+16+16+16+16+16+1 StarNum = 0-96
const static char StarCode[StarCodesMax][5] =    
{ "*ad*", "*ae*", "*am*", "*as*", "*at*", "*bb*", "*bl*", "*br*", "*ca*", "*cf*", "*cm*", "*cr*", "*ct*", "*cx*", "*db*", "*de*", 
  "*df*", "*dt*", "*e0*", "*e1*", "*e2*", "*e3*", "*e4*", "*e5*", "*e6*", "*fa*", "*fc*", "*fm*", "*fo*", "*fs*", "*ft*", "*im*", 
  "*is*", "*it*",  "*ix*", "*kb*", "*ke*", "*kr*", "*ks*", "*ld*", "*lf*", "*lm*", "*ls*", "*lt*", "*lx*", "*ma*", "*m1*", "*m2*", 
  "*mt*", "*mT*", "*nt*",  "*nT*", "*os*", "*ot*", "*oT*", "*po*", "*r0*", "*r1*", "*r2*", "*r3*", "*rn*", "*ro*", "*rt*", "*rT*", 
  "*sa*", "*sd*", "*se*",  "*sm*", "*ss*", "*st*", "*ta*", "*tb*", "*tp*", "*tt*", "*tw*", "*ua*", "*ul*", "*up*", "*vx*", "*x0*", 
  "*x1*", "*x2*", "*x3*",  "*x4*", "*x5*", "*x6*", "*x7*", "*x8*", "*x9*", "*0R*", "*09*", "*0d*", "*0n*", "*0p*", "*0s*", "*0t*", 
  "*0x*"  };

const static byte StarCodeType[StarCodesMax] =    
{ 57,     59,     1,      1,      1,      2,      36,     5,      6,      56,     7,      50,     8,      51,     3,      9,      
  17,     60,     10,     10,     10,     10,     10,     10,     10,     11,     12,     11,     13,     11,     11,     44,    
  44,     44,     44,     14,     39,     38,     15,     16,     42,     55,     55,     55,     58,     62,     18,     19,     
  20,     20,     21,     21,     22,     23,     23,     25,     37,     26,     40,     41,     49,     27,     24,     24,     
  28,     29,     30,     28,     28,     28,     31,      4,     31,     31,     31,     33,     32,     43,     61,     35,     
  35,     35,     35,     35,     35,     35,     35,     35,     35,     34,     45,     53,     46,     47,     48,     54,     
  52      };


line 1893:

  n = 0;                                                 // for the while loops                                            
  if (PrevButton!=Button) { KeyBrd123 = Math123 = 0; }   // Start at a not b or c if other button previously used
  PrevButton = Button;                                   // Maybe do: if (PrevButton!=Button) if (Math && button!=11) Math123 = 0; 


line 2106

      if (Math && (MathX==1 || MathX==3)) { Math = false; status("Math exit");  MathX = 0; Math123 = 0; ConfigButtons(1); break; }
      if (Math && (MathX==0 || MathX==2)) { MathSet++; if (MathSet>9) MathSet = 0; 
                                            if (ReadMath(MathSet)) { status("Symbol Set Changed"); ConfigButtons(1); break; } 
                                                              else { break; } }           // Try until default reached


line 2500

   padLabel[8][0] = nChar;
   if (NumKeys) { padLabel[5][0] = '+'; padLabel[9][0] = '-'; padColor[5] = Red; 
                  if (nKeysShow) { padColor[8] = DGreen; padLabel[7][0] = 's'; padColor[7] = Red;  } 
                            else { padColor[8] = dCyan;  padLabel[7][0] = 'e'; padColor[7] = Blue; } }
           else { if (MathSet==0) padLabel[5][0] = 's'; else padLabel[5][0] = MathSet+48; 
                  padLabel[7][0] = 'm'; padLabel[9][0] = 'o'; padColor[8] = dCyan; padColor[5] = padColor[7] = Blue;  }


line 2668

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ReadConfig1()
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{ int n;
  File f1 = LittleFS.open("Config1", "r");
  int FSz = f1.size(); // Check for valid Config1
  if (FSz!=Config1Size) { for (int n=0; n<Config1Size; n++) Config1[n] = Config1Reset[n]; WriteConfig1(0); return; }
  f1.read(Config1, Config1Size); 
  f1.close();
  
  KeySkip = Config1[0];
  CheckSerial = Config1[1];
  KeyHeldEnable = Config1[2];
  BLOnOff = Config1[3];   
  Rotate180 = Config1[4];                                    // Must check if rotate=0 but calibrate-data is for rotate=180  
  KeyFontBold = Config1[5];                                  // Use: if (calData[4]==5 && Rotate180==1) Rotate180=0;  
  ResetOnceEnable = Config1[6];                              //  or: if (calData[4]==3 && Rotate180==0) Rotate180=1;     
  nKeys = Config1[7];                                        // 
  nChar = Config1[8];     if (nChar<0x30) nChar = 'n';       // Old Config1 with nChar=0x00 then nKeys label = blank 
  nKeysPage = Config1[9]; if (nKeysPage<1) nKeysPage = 8;    // Old Config1 with nKeysPage=0 not valid 
  for (n=1; n<11; n++) nKeysCharSet[n-1] = Config1[9+n];     // if (nKeysCharSet[0]<0x30) reset all 10 to default
  CRLF =  Config1[20];                                       // CR LF Filter
  crlf1 = Config1[21]; 
  crlf2 = Config1[22];
  if (crlf1==0 && crlf2==0) { crlf1 = 0x0D; crlf2 = 0x0A; }  // Reset to default if both NULL character filters
  iList =    Config1[23]; 
  MuteOn =   Config1[24]; 
  VolOn =    Config1[25];
  LayerAxD = Config1[26]; 
  Media =    Config1[27]; 
  XFiles =   Config1[28];
  Brightness = Config1[29];
  BsDNum =   Config1[30];  // 0 = DeleteBackspace  
  RetNum =   Config1[31];  // 8 = ReturnKey
  LayerAD =  Config1[32];  
  KeyFontColour = Config1[33]; if (KeyFontColour) KeyFont = Black; else KeyFont = White;  // Button Font Bold/Normal labels
  SaveLayout =    Config1[34]; 
  OptionOS =      Config1[35]; 
  KeyRepeat =     Config1[36]; if (KeyRepeat<2) KeyRepeat=6; RepTimePeriod = KeyRepeat*100;  // Unusable Macropad if too short
  NormVal =       Config1[37]; 
  DimVal =        Config1[38];
  nKeys34 =       Config1[39];
  strcpy(nDir, (char *)&Config1[40]); // 40-59 60=nDirZ=0 
  for (n=1; n<11; n++) nKeysLnkChar[n-1] = Config1[60+n];    // 61-70 Config1[61-70] 
  nDirX =         Config1[71];
  MLabel =        Config1[72];  SLabel = Config1[73]; TLabel = Config1[74];  
  DelayTimeVal =  Config1[75]; 
  dt25=DelayTimeArr[DelayTimeVal][0];  dt50=DelayTimeArr[DelayTimeVal][1]; 
  dt100=DelayTimeArr[DelayTimeVal][2]; dt200=DelayTimeArr[DelayTimeVal][3]; dt500=DelayTimeArr[DelayTimeVal][4];
  Vol1 =          Config1[76]; Vol3 = Config1[77]; Vol4 = Config1[78]; // If = 1 then enable Volume Up/Dwn in Layouts 1, 3, 4
  ToneOn =        Config1[79];                                         // Bass/Treble controls
  MathSet =       Config1[80];                                         // 0-9 0=Default
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void WriteConfig1(bool Option)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{ int n;
  if (Option==1) {Config1[0] = KeySkip;
                  Config1[1] = CheckSerial;
                  Config1[2] = KeyHeldEnable;
                  Config1[3] = BLOnOff;
                  Config1[4] = Rotate180;
                  Config1[5] = KeyFontBold;
                  Config1[6] = ResetOnceEnable;
                  Config1[7] = nKeys;
                  Config1[8] = nChar;
                  Config1[9] = nKeysPage; 
                  for (n=1; n<11; n++) Config1[9+n] = nKeysCharSet[n-1];
                  Config1[20] = CRLF; 
                  Config1[21] = crlf1; 
                  Config1[22] = crlf2;  
                  Config1[23] = iList;   // iList 0,1
                  Config1[24] = MuteOn; 
                  Config1[25] = VolOn;
                  Config1[26] = LayerAxD;                  
                  Config1[27] = Media; 
                  Config1[28] = XFiles;
                  Config1[29] = Brightness;
                  Config1[30] = BsDNum;  // 0 = DeleteKey  
                  Config1[31] = RetNum;  // 8 = ReturnKey
                  Config1[32] = LayerAD; // LayerADLetter (A-D) = LayerAD (0-3) + 65 -> 0-3 => A-D
                  Config1[33] = KeyFontColour; 
                  Config1[34] = SaveLayout; 
                  Config1[35] = OptionOS;   
                  Config1[36] = KeyRepeat;
                  Config1[37] = NormVal; 
                  Config1[38] = DimVal; 
                  Config1[39] = nKeys34;                  
                  strcpy((char *)&Config1[40], nDir); // 40-59 60=nDirZ=0                    
                  for (n=1; n<11; n++) Config1[60+n] = nKeysLnkChar[n-1];   // Config1[61-70] 
                  nDirX       = Config1[71];
                  Config1[72] = MLabel; Config1[73] = SLabel; Config1[74] = TLabel;  
                  Config1[75] = DelayTimeVal; 
                  Config1[76] = Vol1; Config1[77] = Vol3; Config1[78] = Vol4; // If = 1 then enable Volume Up/Dwn in Layouts 1, 3, 4 
                  Config1[79] = ToneOn;                                       // Bass/Treble controls
                  Config1[80] = MathSet;                                      // 0-9 0=Default
                }
  
  File f1 = LittleFS.open("Config1", "w"); 
  if (Option==2) f1.write(Config1Reset, Config1Size);   // Reset all to default - could be Rotate180 problem
            else f1.write(Config1,      Config1Size);   // Write current Config1 values if Option = 0 or 1
  f1.close();  
}



line 2568

///////////////////////
void SaveMath(byte m)
///////////////////////
{ File f1;
  char MathN[6]  = "MathX";
  if (m<9) MathN[4] = m+48;    // Filename on SDcard Math0 to Math9 If m=10 (*ma* no number added), then save to MathX
  
  f1 = SDFS.open(MathN, "w"); 
  f1.write((char *)MathLabel, sizeof(MathLabel));  // 288 bytes
  f1.write((char *)MathNum,   sizeof(MathNum));    // 720 bytes
  f1.write((char *)MathName,  sizeof(MathName));   // 4608 bytes  
  f1.close();  
}

///////////////////////
bool ReadMath(byte m)
///////////////////////
{ File f1; //       012345678901234567890123456
  char MathN[6]  = "Math0";
  char MathS[30] = "SDCard no Symbols File: ";
   
  MathN[4] = m+48;        // Filename on SDcard Math0 to Math9
  strcat(MathS, MathN);
  if (SDFS.exists(MathN)) f1 = SDFS.open(MathN, "r"); else { status(MathS); return false; }
  int StrLen = f1.size();    // 5616 bytes size  
  // f1.seek(position) not needed below          
  f1.readBytes((char *)MathLabel, sizeof(MathLabel));
  f1.readBytes((char *)MathNum,   sizeof(MathNum));
  f1.readBytes((char *)MathName,  sizeof(MathName));
  f1.close(); 
  
  MathSet = m; 
  return true; 
}



line 2827

      if (!SDFS.exists("Math0"))                SaveMath(0);                                            // Save default Symbols values


line 3659

        case 62: ///////////////////// KeyBrdByte[1]==0x6d&&KeyBrdByte[2]==0x61 *ma*n *ma*0-9 Math0-Math9 Symbol Sets
      { char MathS[32] = "SDCard Symbol Set Mathx loaded";
        if (knum==4) SaveMath(10); { status("MathX saved on SDCard"); StarOk = true; break; }
        if (b>9) { status("Add number 0-9 to *ma*");  }                       // Use the [ADD]ed number to assign 0-9 only
            else { if (ReadMath(b)) { MathS[22] = b+48; status(MathS); }  }   // *ma*0-9 = Default Symbol Keys Set from file Math0 on SDCard or Math1 - Math9 loaded
        StarOk = true; break; } 


